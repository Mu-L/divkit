package divkit.dsl.expression.generator

import divkit.dsl.expression.generator.model.Signature
import org.jetbrains.annotations.TestOnly
import java.io.File
import java.io.FileWriter
import java.io.Writer

class DivkitCodegen {
    private val reservedNames: List<String> = listOf(
        "as", "break", "class", "continue", "do", "else", "false", "for", "fun", "if", "in", "interface", "is", "null",
        "object", "package", "return", "super", "this", "throw", "true", "try", "typealias", "typeof", "val", "var",
        "when", "while", "toString", "equals", "hashCode"
    )

    private val preprocessor = DivkitSignaturesPreprocessor()

    fun generateCode(
        signatures: List<Signature>,
        packageName: String,
        outputDir: File,
        outputFilename: String = "Functions.kt",
    ) {
        val codegenSignatures = preprocessor.toCodegenSignatures(signatures)
        FileWriter(File(outputDir, outputFilename)).use { fileWriter ->
            generateCode(fileWriter, packageName, codegenSignatures)
        }
    }

    @TestOnly
    fun generateCode(
        fileWriter: Writer,
        packageName: String,
        codegenSignatures: List<CodegenSignature>,
    ) {
        writeKtHeader(fileWriter, packageName)

        codegenSignatures.forEach { signature ->
            writeFunctionsForSignature(fileWriter, signature)
        }
    }

    private fun writeKtHeader(
        writer: Writer,
        packageName: String,
    ) {
        // Package of kotlin file.
        writer.appendLine("// GENERATED BY divkit/public/json-builder/kotlin/expression-dsl-generator")
        writer.appendLine()
        writer.appendLine("@file:Suppress(\"ktlint\", \"UNUSED_PARAMETER\", \"unused\")")
        writer.appendLine()
        writer.appendLine("package $packageName")
        writer.appendLine()
    }

    private fun writeExtensionFunction(
        writer: Writer,
        signature: CodegenSignature,
    ) {
        require(signature.arguments.size == 1)
        val name = signature.name
        if (name in reservedNames) {
            return
        }

        writeSignatureDocumentation(writer, signature, extension = true)
        writer.appendLine()
        val jvmName = StringBuilder().apply {
            append("extension_")
            append(signature.name)
            signature.arguments.forEach { argument ->
                append(argument.type.resolveKotlinBasicType())
            }
        }.toString()
        writer.appendLine("@JvmName(\"$jvmName\")")
        val argumentType = signature.arguments[0].type
        val argumentKotlinType = argumentType.resolveKotlinArgumentType()
        val receiverType = "Expression<$argumentKotlinType>"
        writer.appendLine("fun $receiverType.$name(@Suppress(\"UNUSED_PARAMETER\", \"LocalVariableName\") `do not use`: Unit = Unit) = $name(this)")
        writer.appendLine()
    }

    private fun writeFunctionsForSignature(
        writer: Writer,
        signature: CodegenSignature,
    ) {
        writeSignatureDocumentation(writer, signature)
        writer.appendLine()
        val jvmName = StringBuilder().apply {
            append(signature.name)
            signature.arguments.forEach { argument ->
                append(argument.type.resolveKotlinBasicType())
            }
        }.toString()
        writer.appendLine("@JvmName(\"$jvmName\")")
        writer.appendLine("fun ${signature.name}(")
        signature.arguments.forEachIndexed { index, codegenArgument ->
            val argumentType = codegenArgument.type.resolveKotlinArgumentType()
            if (codegenArgument.isVararg) {
                writer.appendLine("    vararg varargs: Expression<$argumentType>,")
            } else {
                writer.appendLine("    param$index: Expression<$argumentType>,")
            }
        }
    val returnType = signature.returnType.resolveKotlinType()
        writer.appendLine("): Expression<$returnType> =")
        writer.appendLine("    FunctionExpression(")
        writer.appendLine("        \"${signature.name}\",")
        signature.arguments.forEachIndexed { index, codegenArgument ->
            if (codegenArgument.isVararg) {
                writer.appendLine("        *varargs,")
            } else {
                writer.appendLine("        param$index,")
            }
        }
        writer.appendLine("    )")
        writer.appendLine()

        if (signature.supportsExtension()) {
            writeExtensionFunction(writer, signature)
        }
    }

    private fun writeSignatureDocumentation(
        writer: Writer,
        signature: CodegenSignature,
        extension: Boolean = false,
    ) {
        writer.appendLine("/**")
        writer.appendLine(" * ${signature.description}")
        writer.appendLine(" *")
        signature.arguments.forEachIndexed { index, argument ->
            if (extension) {
                writer.append(" * @receiver ")
            } else {
                if (argument.isVararg) {
                    writer.append(" * @param varargs ")
                } else {
                    writer.append(" * @param param${index} ")
                }
            }
            writer.append(argument.description)
            writer.appendLine()
        }
        writer.appendLine(" * @return function expression")
        writer.appendLine(" */")
    }
}

private fun CodegenSignature.supportsExtension(): Boolean {
    return arguments.size == 1 && !arguments[0].isVararg
}
